# 引用和借用

## 引用

引用就是没有“所有权”的指针

别名和可变性不可同时存在
别名：通过不同的变量访问同一数据。

灾难举例：
通过释放别名数据，使得另一个变量指向已经释放的内存。
通过修改别名数据，是的另一个变量期望的运行时属性失效。
通过同时修改别名数据，导致与另一个变量发生数据竞争，产生不可预测的行为。

### 指针安全原则

数据不应该同时“被别名引用”和“具有可变性”

Box（有“所有权”的指针）：不能别名
将一个Box变量付给另一个变量：移动了所有权

引用（无“所有权”的指针）：旨在临时创建别名

## 借用检查器

Rust通过借用检查其确保引用的安全性。

变量对数据有三种权限：
读（R）：数据可以被复制到另一个位置
写（W）：数据可以被修改
拥有（O）：数据可以被移动或释放

这些权限在运行时并不存在，仅在编译器内部存在。
默认情况下，变量对其数据具有读/拥有权限（RO）。
如果一个变量被注解为let mut，那么它还具有写权限（W）。
关键：引用可以临时移除这些权限。

## 位置与权限

权限定义在位置上的。
位置是任何可以放在赋值语句左侧的东西。 _ = 

e.g.
变量 a
位置的解引用 *a
位置的数组访问 a[0]
位置的字段访问 a.0
上述任何组合 *((*a)[0].1)

当位置变成不使用的时候，会失去权限，因为有些权限是互斥的。

## 可变引用

可变引用提供对数据`唯一的`且`非拥有`的访问

不可变引用（共享引用）：只读的
可变引用（独占引用）：在不移动数据的情况下，临时提供可变访问

可变引用可临时被降级为只读引用

权限在引用生命周期结束时被返回

数据必须在其所有引用存在的期间存活

## 流动权限 F

当我们在函数中使用引用作为参数或返回值时，需要确保这些引用的安全性。F权限就是用来追踪这种"流动"的合法性。
F权限的特点是一旦获得就不会在函数体内改变，这确保了引用在整个函数执行期间都是合法的。这与读（R）、写（W）权限不同，后者可能会随着代码的执行而变化。
这种设计帮助编译器在编译时就能确保引用的安全使用，防止悬垂引用（dangling references）的产生。

在表达式使用输入引用或返回输出引用时需要
F权限在函数体内不会发生变化
如果一个引用被允许在特定表达式中使用（即流动），那么它就具有F权限